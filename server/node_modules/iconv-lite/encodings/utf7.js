i});if(r&e.constants.W_OK)throw createError("NO_ACCESS",{asarPath:s,filePath:i})};const{readFile:N}=e;e.readFile=function(t,e,r){const n=splitPath(t);return n.isAsar?fsReadFileAsar(t,e,r):N.apply(this,arguments)};const{readFile:O}=e.promises;e.promises.readFile=function(t,e){const r=splitPath(t);if(!r.isAsar)return O.apply(this,arguments);const n=a.promisify(fsReadFileAsar);return n(t,e)};const{readFileSync:g}=e;e.readFileSync=function(t,r){const n=splitPath(t);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.getFileInfo(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});if(0===c.size)return r?"":s.Buffer.alloc(0);if(c.unpacked){const t=o.copyFileOut(a);return e.readFileSync(t,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:f}=r,l=s.Buffer.alloc(c.size),u=o.getFdAndValidateIntegrityLater();if(!(u>=0))throw createError("NOT_FOUND",{asarPath:i,filePath:a});return logASARAccess(i,a,c.offset),e.readSync(u,l,0,c.size,c.offset),validateBufferIntegrity(l,c.integrity),f?l.toString(f):l};const{readdir:w}=e;e.readdir=function(t,r={},n){const s=splitPath(t);if("function"==typeof r&&(n=r,r={}),!s.isAsar)return w.apply(this,arguments);const{asarPath:a,filePath:o}=s,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(n,[t])}const f=c.readdir(o);if(f)if(r.withFileTypes){const t=[];for(const r of f){const s=i.join(o,r),f=c.stat(s);if(!f){const t=createError("NOT_FOUND",{asarPath:a,filePath:s});return void nextTick(n,[t])}f.isFile?t.push(new e.Dirent(r,e.constants.UV_DIRENT_FILE)):f.isDirectory?t.push(new e.Dirent(r,e.constants.UV_DIRENT_DIR)):f.isLink&&t.push(new e.Dirent(r,e.constants.UV_DIRENT_LINK))}nextTick(n,[null,t])}else nextTick(n,[null,f]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(n,[t])}},e.promises.readdir=a.promisify(e.readdir);const{readdirSync:m}=e;e.readdirSync=function(t,r){const n=splitPath(t);if(!n.isAsar)return m.apply(this,arguments);const{asarPath:s,filePath:a}=n,o=getOrCreateArchive(s);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:s});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:s,filePath:a});if(r&&r.withFileTypes){const t=[];for(const r of c){const n=i.join(a,r),c=o.stat(n);if(!c)throw createError("NOT_FOUND",{asarPath:s,filePath:n});c.isFile?t.push(new e.Dirent(r,e.constants.UV_DIRENT_FILE)):c.isDirectory?t.push(new e.Dirent(r,e.constants.UV_DIRENT_DIR)):c.isLink&&t.push(new e.Dirent(r,e.constants.UV_DIRENT_LINK))}return t}return c};const{internalModuleReadJSON:F}=u("fs");u("fs").internalModuleReadJSON=t=>{const r=splitPath(t);if(!r.isAsar)return F(t);const{asarPath:n,filePath:i}=r,a=getOrCreateArchive(n);if(!a)return[];const o=a.getFileInfo(i);if(!o)return[];if(0===o.size)return["",!1];if(o.unpacked){const t=a.copyFileOut(i),r=e.readFileSync(t,{encoding:"utf8"});return[r,r.length>0]}const c=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))return[];logASARAccess(n,i,o.offset),e.readSync(f,c,0,o.size,o.offset),validateBufferIntegrity(c,o.integrity);const l=c.toString("utf8");return[l,l.length>0]};const{internalModuleStat:S}=u("fs");if(u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return S(t);const{asarPath:r,filePath:n}=e,s=getOrCreateArchive(r);if(!s)return-34;const i=s.stat(n);return i?i.isDirectory?1:0:-34},"win32"===t.platform){const{mkdir:t}=e;e.mkdir=(e,r,n)=>{"function"==typeof r&&(n=r,r={});const s=splitPath(e);if(s.isAsar&&s.filePath.length>0){const t=createError("NOT_DIR");nextTick(n,[t])}else t(e,r,n)},e.promises.mkdir=a.promisify(e.mkdir);const{mkdirSync:r}=e;e.mkdirSync=function(t,e){const n=splitPath(t);if(n.isAsar&&n.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(e){return function(){const r=t.noAsar;t.noAsar=!0;try{return e.apply(this,arguments)}finally{t.noAsar=r}}}overrideAPI(e,"copyFiexports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


