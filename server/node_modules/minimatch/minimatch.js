module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return require('path') } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require('brace-expansion')

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split( í7¹Î.»Êxø[NŸƒz ØN   İä„Iş’Ø ³ÔyPß•[. >ÍïFT©ÀA•c”Éuİæ4»ä7ı;g‡çèo;œvÊ°=<ËÓp:È˜f—i7¹Œw©ç.õ İä„Iş’Ø İä„Iş’Øi7¹Œw©çä7ı;g‡çèo;œvƒPC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,Oi7¹ŒÄâtI}B[´$M‹Mi7¹Œ¡†:nu^–Ï¹6YË›q‰åùšş†sååğ˜ÎÃá1®ûM.Ûor]sååù›m/séå9+/Ïßl{YÎ%¿éß9;<GÛá´;.õi7¹Œw©çi7¹Œw©ç w@@ (f  	J Å  ****d—¹G•Ø           ^UJş’Øb.Jş’Ø^UJş’Ø£Ş»|NéP{ôÖ°o0şx z Š  ” à  7$@»œ%¥0§2©[²v»•ÁœÑ¢à®ê°÷·şºÇÉËk-t0É>ĞBİDêMï  a8œ‡éé·û¥¿İ         C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç’ßôïœ£¿ípÚC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç’ßôïœ£¿ípÚÍ…‡Çëğ¹ìRÏßn         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeù‹ü¦çìğım‡Óî<<^‡Ïe—zşv ^UJş’Ø     ^UJş’Ø #ù«ä_ˆÔæ4»a8œ‡éé·û¥¿İä7ı;g‡çèo;œvÊéÓ	2¦Ùeğğx>—]êùÛ.õüí ^UJş’Ø ^UJş’Øğğx>—]êùÛä7ı;g‡çèo;œvƒPC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,Oğğx>—ğğx>—A¨¡[—ås®MÖ²Áf\by¾¦¿á\y9<¦sÃpxŒë~“Ëßö›\g—ç\yyşfÛË\zyNçÊËó7Û^–sÉoúwÎÏÑßv8íN.õüíğğx>—]êùÛğğx>—]êùÛ w@@(f  	J Å  ****›XƒG•Ø           Ä6Iş’Øóš€Iş’Ø˜Åş’Øj:Ö´œ±„°QsfIş„ † ‹  ×  &$/\‚»˜¡%£-¥0¹2»[ÄfÍvŞœä¢í®ı°·ºÇÉ&Ën&u-…0Ó>ØBáDêMï           C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç’ßôo;œvC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç’ßôo;œvsÓnrïRÏ       ?æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeù‹ü¦Ûá´û•v“Ëx—zÄâtI}B[´$M‹M¹6YË› Ä6Iş’Ø    í7¹Î.»Êxø[NŸƒz ØN   Ä6Iş’Ø G‹úâ€0Ä
 >ÍïFT©ÀA•c”Éuİæ4»ä7ıÛ§İÊ°=<ËÓp:È˜f—i7¹Œw©ç.õ Ä6Iş’Ø Ä6Iş’Øi7¹Œw©çä7ıÛ§İ ÔPÇ­ÎËò9×&kÙ`3.±<_Óßp®¼Ó¹a8<Æu¿ÉåoûM®³Ës®¼<³íe.½<§sååù›m/ËSi7¹ŒÄâtI}B[´$M‹Mi7¹Œ¡†:nu^–Ï¹6YË›q‰åùšş†sååğ˜ÎÃá1®ûM.Ûor]sååù›m/séå9+/Ïßl{YÎ%¿éßv8íN.õi7¹Œw©çi7¹Œw©ç w@@ (f  	J Å  ****d—¹G•Ø           ³DJş’ØÁöJş’Ø³DJş’Ø£Ş»|NéP{ôÖ°o0şx z Š  ” Û  -$6»Œ%•0—2™[¢v«•±œÁ¢Ê®Ô°á·èºñÇúÉËO-X0§>®B»DÈMÍ  a8œ‡éé·û¥¿İ         C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç’ßôo;œvC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç’ßôo;œvsááñ:|.»Ôó·         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeù‹ü¦Ûá´û×ásÙ¥¿İ ³DJş’Ø     ³DJş’Ø X¼wH{Œ¢‰æ4»a8œ‡éé·û¥¿İä7ıÛ§İÊéÓ	2¦Ùeğğx>—]êùÛ.õüí ³DJş’Ø ³DJş’Øğğx>—]êùÛä7ıÛ§İ ÔPÇ­ÎËò9×&kÙ`3.±<_Óßp®¼Ó¹a8<Æu¿ÉåoûM®³Ës®¼<³íe.½<§sååù›m/ËSğğx>—ğğx>—A¨¡[—ås®MÖ²Áf\by¾¦¿á\y9<¦sÃpxŒë~“Ëßö›\g—ç\yyşfÛË\zyNçÊËó7Û^–sÉoú·N»S.õüíğğx>—]êùÛğğx>—]êùÛ w@@(f  	J Å  ****˜Åş’Ø            uIş’ØuIş’ØuIş’Ø'85 ÷›B¸GkˆòRş€ ‚ ‡ Œ ×  &$/\ƒ»™¢%¤0¦2¨[±fºvËœÑ¢ß®ï°õ·úºÇÉË_&b-r0Á>ÆBÌDÒM×           C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠåïû¼,ÿšÓe6C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠåïû¼,ÿšÓe6™v©ç         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeùK,ßçeù×œ.³É¯°K=ÄâtI}B[´$M‹M¹6YË› uIş’Ø       uIş’Ø !›š˜Î¬Y >ÍïFT©ÀA•c”Éuİæ4»bùû>/Ë¿æt™MÊ°=<ËÓp:È˜f—a—z.õ uIş’Ø uIş’Øa—zbùû>/Ë¿æt™M¡†:nu^–Ï¹6YË›q‰åùšş†sååğ˜ÎÃá1®ûM.Ûor]sååù›m/séå9+/Ïßl{Ya ÄâtI}B[´$M‹Maj¨ãVçeùœk“µl°—X¯éo8W^éÜ0ãºßäò·ı&×Ùå9W^¿Ùö2—^Ó¹òòüÍ¶—å\±ü}Ÿ—å_sºÌ&§ .õa—za—z w@@(f  	J Å  ****˜Åş’Ø            ¤H,Iş’Ø¤H,Iş’Ø¤H,Iş’ØHöC³¦Av–˜£í¨ş€ ‚ ‡ Œ ×  &$/\ƒ»™¢%¤0¦2¨[±fºvËœÑ¢ß®ï°õ·úºÇÉË_&b-r0Á>ÆBÌDÒM×           C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠåïû¼,ÿšÓe6C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠåïû¼,ÿšÓe6™+v©ç         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeùK,ßçeù×œ.³É/±K=ÄâtI}B[´$M‹M¹6YË› ¤H,Iş’Ø       ¤H,Iş’Ø Nöğ(İ–¢ >ÍïFT©ÀA•c”Éuİæ4»bùû>/Ë¿æt™MÊ°=<ËÓp:È˜f—b—z.õ ¤H,Iş’Ø ¤H,Iş’Øb—zbùû>/Ë¿æt™M¡†:nu^–Ï¹6YË›q‰åùšş†sååğ˜ÎÃá1®ûM.Ûor]sååù›m/séå9+/Ïßl{Yb ÄâtI}B[´$M‹Mbj¨ãVçeùœk“µl°—X¯éo8W^éÜ0ãºßäò·ı&×Ùå9W^¿Ùö2—^Ó¹òòüÍ¶—å\±ü}Ÿ—å_sºÌ&§ .õb—zb—z w@@(f  	J Å  ****d—¹G•Ø?           ;#Jş’ØFüJş’Ø;#Jş’Ø£Ş»|NéP{ôÖ°o0şx z Š  ” ß  5$>»™%¢0¤2¦[¯v¸•¾œÎ¢Ü®æ°ó·úºÇÉËf-o0Ã>ÊB×DäMé  a8œ‡éé·û¥¿İ         C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠåïû¼,ÿšÓe6C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠåïû¼,ÿšÓe6™×ásÙ¥¿İ         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeùK,ßçeù×œ.³É/xx¼ŸË.õüí ;#Jş’Ø     ;#Jş’Ø ìÊé•›¡æ4»a8œ‡éé·û¥¿İbùû>/Ë¿æt™MÊéÓ	2¦Ùeğğx>—]êùÛ.õüí ;#Jş’Ø ;#Jş’Øğğx>—]êùÛbùû>/Ë¿æt™M¡†:nu^–Ï¹6YË›q‰åùšş†sååğ˜ÎÃá1®ûM.Ûor]sååù›m/séå9+/Ïßl{Yğğx>—ğğx>—A¨¡[—ås®MÖ²Áf\by¾¦¿á\y9<¦sÃpxŒë~“Ëßö›\g—ç\yyşfÛË\zyNçÊËó7Û^–sÅò÷}^–Íé2›œ.õüíğğx>—]êùÛğğx>—]êùÛ w@@(f  	J Å  ****˜Åş’Ø            3š<Iş’Ø3š<Iş’Ø3š<Iş’Ø Ê¤¶6s=“ÿ·LÖç¸äş€ ‚ ‡ Œ Î  $ \n»„%0‘2“[œf¥v¶œ¼¢Á®Ñ°Ú·ßºèÇñÉúË>&D-T0œ>¡BªD³M¸           C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠÃzC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠÃz.ùın»Ôs         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeùKÖ¿ÈïwÛ¥ÄâtI}B[´$M‹M¹6YË› 3š<Iş’Ø       3š<Iş’Ø ˜dğ4”ºf >ÍïFT©ÀA•c”Éuİæ4»â°Ê°=<ËÓp:È˜f—ä÷»íRÏ.õ 3š<Iş’Ø 3š<Iş’Øä÷»íRÏâ°„ê¸ÕyY>çÚd-lÆ%–çkúÎ•—Ãc:7‡Ç¸î7¹üm¿ÉuvyÎ•—ço¶½Ì¥—çt®¼<³íey
ä÷»ÄâtI}B[´$M‹Mä÷»BuÜê¼,Ÿsm²–6ãËó5ıçÊËá1†Ãc\÷›\ş¶ßä:»<çÊËó7Û^æÒËs:W^¿Ùö²œ+ëS.õä÷»íRÏä÷»íRÏ w@@(f  	J Å  ****d—¹G•Ø-           ëJş’ØšÄJş’ØëJş’Ø£Ş»|NéP{ôÖ°o0şx z Š  ” Ö  $$-»%ˆ0Š2Œ[•v•¤œ´¢¹®Ã°Ğ·×ºàÇéÉöË:-C0>•B¢D¯M´  a8œ‡éé·û¥¿İ         C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠÃzC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠÃz.<<^‡Ïe—zşv         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeùKÖ¿àáñ:|.»Ôó· ëJş’Ø     ëJş’Ø ñŸû@Ìâ–*æ4»a8œ‡éé·û¥¿İâ°ÊéÓ	2¦Ùeğğx>—]êùÛ.õüí ëJş’Ø ëJş’Øğğx>—]êùÛâ°„ê¸ÕyY>çÚd-lÆ%–çkúÎ•—Ãc:7‡Ç¸î7¹üm¿ÉuvyÎ•—ço¶½Ì¥—çt®¼<³íey
ğğx>—ğğx>—A¨¡[—ås®MÖ²Áf\by¾¦¿á\y9<¦sÃpxŒë~“Ëßö›\g—ç\yyşfÛË\zyNçÊËó7Û^–sÅa}
.õüíğğx>—]êùÛğğx>—]êùÛ w@@(f  	J Å  ****ıÎƒG•Ø            úIş’Ø¿ŸùIş’Ø˜Åş’Øì}ã»ô¨“ï7tcş„ † ‹  Ò  $$\r»ˆ‘%“-•0©2«[´f½vÎœÔ¢Ù®é°ò·÷º Ç	ÉËV&\-l0´>¹BÂDËMĞ           C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠÃzC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,çŠÃzn¼^Ç»Ôs         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeùKÖ¿âõ:Ş¥ÄâtI}B[´$M‹M¹6YË›  úIş’Ø    í7¹Î.»Êxø[NŸƒz ØN    úIş’Ø ûa‚Ôå¤ >ÍïFT©ÀA•c”Éuİæ4»â°Ê°=<ËÓp:È˜f—ñzïRÏ.õ  úIş’Ø  úIş’ØñzïRÏâ°„ê¸ÕyY>çÚd-lÆ%–çkúÎ•—Ãc:7‡Ç¸î7¹üm¿ÉuvyÎ•—ço¶½Ì¥—çt®¼<³íey
ñzÄâtI}B[´$M‹MñzBuÜê¼,Ÿsm²–6ãËó5ıçÊËá1†Ãc\÷›\ş¶ßä:»<çÊËó7Û^æÒËs:W^¿Ùö²œ+ëS.õñzïRÏñzïRÏ w@@ (f  	J Å  ****šòƒıºØ********   ÉIş’ØIş’Ø¹-#Kù›Øõ3Ü•˜©7½"AÌ¦ó:
şx z  „ Ô  ($1»‰%’0”2–TŸ[§v°œ¶¢Ö®â·çºğÇùÈşÉËXÏ]-b0¸>ÂBÇDÌMÑ ÿ         C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹@qX\fsáìú9ínÑåa÷Üü–·[ôrÎÓË-vš^–‡ÙsC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹@qX\fsáìú9ínÑåa÷Üü–·[ôrÎÓË-vš^–‡Ùs.;-         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿ÉuvyşŠÃâ2ûg×Ïiw‹.»çæ·¼İ¢—Ûpv˜^n±Óô²<Ì¿Øi1 ÉIş’Ø      yIş’Øæ7›\– Ü¥­ü5æ4»pvıœv·èò°{n~ËÛ-z¹g‡éå;M/ËÃì9Æ4»2¿Ùä²ì´ ÉIş’Ø ÉIş’Øì´Æ7›\–pvıœv·èò°{n~ËÛ-z¹g‡éå;M/ËÃì95Ôq«ó²|ÎµÉZ6ØŒK,Ï×ô7œ+/‡ÇtnqİorùÛ~“ëìòœ‡Åev
ì´ì´ì´„ê¸ÕyY>çÚd-lÆ%–çkúÎ•—Ãc:7‡Ç¸î7¹üm¿ÉuvyÎŠÃâ2›g×Ïiw‹.»çæ·¼İ¢—Ûpv˜^n±Óô²<Ì§ Ä´¼<¦¿åyì´ì´ €p(f  		J 	Å  ****Ê÷¹G•Ø           :qJş’ØEJJş’Ø:qJş’Ø£Ş»|NéP{ôÖ°o0şx z Š  ” ç  E$N»±%º0¼2¾[ÇvĞ•Öœæ¢ü®°·º#Ç,É9Ë-—0ó>úBDM  a8œ‡éé·û¥¿İ         C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç¶Ãló[Ş.“¿ğğx>—¿êùÛC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç¶Ãló[Ş.“¿ğğx>—¿êùÛÍ…‡Çëğ¹ìRÏßn         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeù«f›ßòv™ü…‡Çëğ¹üUÏßî<<^‡Ïe—zşv :qJş’Ø     :qJş’Ø ñd#ä¶¶Cæ4»a8œ‡éé·û¥¿İí0Ûü–·Ëä/<<^‡Ïå¯zşvÊéÓ	2¦Ùeğğx>—]êùÛ.õüí :qJş’Ø :qJş’Øğğx>—]êùÛí0Ûü–·Ëä/<<^‡Ïå¯zşvƒPC·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,Oğğx>—ğğx>—A¨¡[—ås®MÖ²Áf\by¾¦¿á\y9<¦sÃpxŒë~“Ëßö›\g—ç\yyşfÛË\zyNçÊËó7Û^–sÛa¶ù-o—É_xx¼ŸË_õüíN.õüíğğx>—]êùÛğğx>—]êùÛ w@@(f  	J Å  ****Ê÷¹G•Ø          ©¹Jş’Ø»DJş’Ø©¹Jş’Ø£Ş»|NéP{ôÖ°o0şx z Š  ” ì  P$Y»Á%Ê0Ì2Î[×và•æœö¢ ®
°·º'Ç0É=Ë—- 0>BD"M'  a8œ‡éé·û¥¿İ         C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç¶ëlzZ^†¿¹ğğx>—ç\xx¼ŸË­0C·:/Ëç\›¬eƒÍ¸Äò|MÃ¹òrxLç†áğ×ı&—¿í7¹Î.Ï¹òòüÍ¶—¹ôòœÎ•—ço¶½,ç¶ëlzZ^†¿¹ğğx>—ç\xx¼ŸË­0¯Ãç²K=»         æ4»¬ê^ÕyY>Ùd-lö"–çkúş’—Ãcú+‡Ç^î7¹üm¿Éuvyş’—ço¶½ü¢—çô—¼<³íeù«]gÓÓò2üı‚‡Çëğ¹<ÁÃãuø\n…_ğğx>—]êùÛ ©¹Jş’Ø     ©¹Jş’Ø DD0Ÿ4!åA