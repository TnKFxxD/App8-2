// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    const loose = this.options.loose
    range = range.trim()
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace)
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    return range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const Comparator = require('./comparator')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = require('../internal/re')

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0`
      } else {
        ret = `>=${M}.${m}.0 <${+M + 1}.0.0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          } <${M}.${m}.${+p + 1}`
        } else {
          ret = `>=${M}.${m}.${p
          } <${M}.${+m + 1}.0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.repl"ipcMain",loader:()=>r(/*! ./ipc-main */"./lib/browser/api/ipc-main.ts")},{name:"inAppPurchase",loader:()=>r(/*! ./in-app-purchase */"./lib/browser/api/in-app-purchase.ts")},{name:"Menu",loader:()=>r(/*! ./menu */"./lib/browser/api/menu.ts")},{name:"MenuItem",loader:()=>r(/*! ./menu-item */"./lib/browser/api/menu-item.ts")},{name:"MessageChannelMain",loader:()=>r(/*! ./message-channel */"./lib/browser/api/message-channel.ts")},{name:"nativeTheme",loader:()=>r(/*! ./native-theme */"./lib/browser/api/native-theme.ts")},{name:"net",loader:()=>r(/*! ./net */"./lib/browser/api/net.ts")},{name:"netLog",loader:()=>r(/*! ./net-log */"./lib/browser/api/net-log.ts")},{name:"Notification",loader:()=>r(/*! ./notification */"./lib/browser/api/notification.ts")},{name:"powerMonitor",loader:()=>r(/*! ./power-monitor */"./lib/browser/api/power-monitor.ts")},{name:"powerSaveBlocker",loader:()=>r(/*! ./power-save-blocker */"./lib/browser/api/power-save-blocker.ts")},{name:"protocol",loader:()=>r(/*! ./protocol */"./lib/browser/api/protocol.ts")},{name:"safeStorage",loader:()=>r(/*! ./safe-storage */"./lib/browser/api/safe-storage.ts")},{name:"screen",loader:()=>r(/*! ./screen */"./lib/browser/api/screen.ts")},{name:"session",loader:()=>r(/*! ./session */"./lib/browser/api/session.ts")},{name:"ShareMenu",loader:()=>r(/*! ./share-menu */"./lib/browser/api/share-menu.ts")},{name:"systemPreferences",loader:()=>r(/*! ./system-preferences */"./lib/browser/api/system-preferences.ts")},{name:"TouchBar",loader:()=>r(/*! ./touch-bar */"./lib/browser/api/touch-bar.ts")},{name:"Tray",loader:()=>r(/*! ./tray */"./lib/browser/api/tray.ts")},{name:"View",loader:()=>r(/*! ./view */"./lib/browser/api/view.ts")},{name:"webContents",loader:()=>r(/*! ./web-contents */"./lib/browser/api/web-contents.ts")},{name:"WebContentsView",loader:()=>r(/*! ./web-contents-view */"./lib/browser/api/web-contents-view.ts")},{name:"webFrameMain",loader:()=>r(/*! ./web-frame-main */"./lib/browser/api/web-frame-main.ts")}],t.browserModuleList.push({name:"desktopCapturer",loader:()=>r(/*! ./desktop-capturer */"./lib/browser/api/desktop-capturer.ts")}),t.browserModuleList.push({name:"ImageView",loader:()=>r(/*! ./views/image-view */"./lib/browser/api/views/image-view.ts")})},"./lib/browser/api/native-theme.ts":
/*!*****************************************!*\
  !*** ./lib/browser/api/native-theme.ts ***!
  \*****************************************/
/*! no static exports found */function(e,t,r){"use strict";const{nativeTheme:o}=process._linkedBinding("electron_common_native_theme");e.exports=o},"./lib/browser/api/net-log.ts":
/*!************************************!*\
  !*** ./lib/browser/api/net-log.ts ***!
  \************************************/
/*! no static exports found */function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(/*! electron/main */"./lib/browser/api/exports/electron.ts");t.default={startLogging:async(e,t)=>{if(o.app.isReady())return o.session.defaultSession.netLog.startLogging(e,t)},stopLogging:async()=>{if(o.app.isReady())return o.session.defaultSession.netLog.stopLogging()},get currentlyLogging(){return!!o.app.isReady()&&o.session.defaultSession.netLog.currentlyLogging}}},"./lib/browser/api/net.ts":
/*!********************************!*\
  !*** ./lib/browser/api/net.ts ***!
  \********************************/
/*! no static exports found */function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.request=t.ClientRequest=void 0;const o=r(/*! url */"url"),n=r(/*! stream */"stream"),s=r(/*! electron/main */"./lib/browser/api/exports/electron.ts"),{isOnli